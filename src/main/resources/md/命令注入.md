# 命令注入

---
在Java中主要通过调用Runtime.getRuntime.exec()方法或者ProcessBuilder.start()来执行命令。
### 常见业务场景
业务逻辑处理时会直接拼接用户可控参数，然后去执行系统命令或者拼凑回调函数代码达到对应的业务效果。常见的场景如下：

* 图片处理（例如通过命令进行文件的复制、剪切、删除等）
* 大文件压缩解压（例如zip、unzip命令）
* 文件转PDF
* 网站监测（例如常见的curl、ping、telnet等）
* 邮件发送（mail）
* 调用shell脚本
* ......

对于 Java 环境中的命令注入，连接符的使用存在一些限制，例如以下代码
```
Runtime.getRuntime().exec("ping " + url);
```
这里因为 URL 可控，因此当我们输入 127.0.0.1&ipconfig 时，拼接出来的系统命令就是 ping 127.0.0.1&ipconfig，该命令在系统终端下是能正常运行的，但是在 Java 环境下就会运行失败，这里因为 Java 在程序处理的过程中，会将 127.0.0.1&ipconfig 当做一个完整的字符串而非两条命令，因此上面的代码不存在命令注入。

所以若代码没有**手动创建**shell来执行命令，即使是对应命令参数部分可控时，也无法使用;、&&等特殊符号进行命令注入。原因是java只把第一个空格前的参数作为命令执行，后面皆作为参数输入。
>**手动创建shell即命令前需要加上bash -c**
> 
> 以下代码，若command为前端传入，则存在命令注入
>```
>new ProcessBuilder(command);
>
>new ProcessBuilder("/bin/sh", "-c", command);
>
>new ProcessBuilder(new String[]{"/bin/sh","-c","/test.sh " + command});
>
>Runtime.getRuntime().exec(new String[]{"/bin/sh","-c",command});
>
>Runtime.getRuntime().exec(new String[]{"/bin/sh","-c","/test.sh " + command});
>```



## 总结

若命令参数完全可控，可以注入任意命令执行

不存在创建shell，无法结合;与&&等特殊符号进行命令注入

存在创建shell并且存在参数注入，可以进行命令注入（例如可控点在-c传入的参数命令后）



