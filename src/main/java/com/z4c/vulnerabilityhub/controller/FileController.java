package com.z4c.vulnerabilityhub.controller;

import com.z4c.vulnerabilityhub.globalException.GlobalException;
import com.z4c.vulnerabilityhub.model.Response;
import com.z4c.vulnerabilityhub.model.ResponseCode;
import com.z4c.vulnerabilityhub.service.FileService;
import io.swagger.annotations.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

@Api(tags = "文件管理")
@RestController()
@RequestMapping("/file")
public class FileController {
    @Autowired
    FileService fileService;

    /*
     * 该方法存在以下缺陷
     *
     * 1、直接使用原始文件名作为服务器上的文件名，容易被攻击者利用进行文件名注入攻击，
     * 如上传一个文件名为 ../../../etc/passwd 的文件，可以让攻击者穿越目录，覆盖指定文件。
     * 2、没有对文件类型进行校验，攻击者可以上传任意类型的文件，从而增加服务器被攻击的风险。
     */
    @ApiOperation("文件上传")
    @PostMapping(value = "/uploadPhoto" , consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<Response<String>> uploadAvatar(
            @ApiParam(value = "上传文件", required = true) @RequestPart("file") MultipartFile file) {
        String savePath = fileService.uploadPhoto(file);
        // 文件上传成功，返回路径
        Response<String> response = new Response<>();
        response.setCode(ResponseCode.SUCCESS.getCode());
        response.setMessage("文件上传成功！");
        response.setData(savePath);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    /*
     *   错误修复方案：
     *   通过获取Content-Type判断文件类型进行白名单校验
     *
     */

    @ApiOperation("文件上传修复-白名单校验文件类型")
    @PostMapping(value = "/uploadPhoto-bad" , consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<Response<String>> uploadAvatarBad(
            @ApiParam(value = "上传文件", required = true) @RequestPart("file") MultipartFile file) {
        String savePath = fileService.uploadFileRandomNameSanitizer(file);
        // 文件上传成功，返回路径
        Response<String> response = new Response<>();
        response.setCode(ResponseCode.SUCCESS.getCode());
        response.setMessage("文件上传成功！");
        response.setData(savePath);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    /*
     *   第一种修复方案：
     *   文件名由服务器通过UUID进行生成，避免文件名中存在导致目录穿越的特殊字符
     *   通过白名单校验，只允许指定后缀文件上传
     */

    @ApiOperation("文件上传修复-白名单校验后缀")
    @PostMapping(value = "/uploadPhoto1" , consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<Response<String>> uploadAvatar1(
            @ApiParam(value = "上传文件", required = true) @RequestPart("file") MultipartFile file) {
        String savePath = fileService.uploadFileRandomNameSanitizer(file);
        // 文件上传成功，返回路径
        Response<String> response = new Response<>();
        response.setCode(ResponseCode.SUCCESS.getCode());
        response.setMessage("文件上传成功！");
        response.setData(savePath);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }


    /*
     * 第二种修复方案：
     *   通过判断保存路径是否在指定路径，避免目录穿越
     *   通过白名单校验，只允许指定后缀文件上传
     */

    @ApiOperation("文件上传修复-限制指定路径")
    @PostMapping(value = "/uploadPhoto2" , consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<Response<String>> uploadAvatar2(
            @ApiParam(value = "上传文件", required = true) @RequestPart("file") MultipartFile file) {
        String savePath = fileService.uploadFileCanonicalSanitizer(file);
        // 文件上传成功，返回路径
        Response<String> response = new Response<>();
        response.setCode(ResponseCode.SUCCESS.getCode());
        response.setMessage("文件上传成功！");
        response.setData(savePath);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @ApiOperation("读取文件")
    @PostMapping("/getFile")
    public ResponseEntity<byte[]> getFile(
            @ApiParam(value = "文件名", required = true)@RequestParam("fileName") String fileName) throws IOException {
        byte[] bytes = fileService.getFile(fileName);
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Disposition", String.format("attachment; filename=\"%s\"", fileName));
        return new ResponseEntity<>(bytes,headers, HttpStatus.OK);
    }

    /*
     *   第一种修复方案：
     *   过滤特殊字符、避免文件名中存在..符号
     *
     */

    @ApiOperation("读取文件-过滤特殊字符")
    @PostMapping("/getFile1")
    public ResponseEntity<byte[]> getFile1(
            @ApiParam(value = "文件名", required = true)@RequestParam("fileName") String fileName) throws IOException {
        if(fileName.contains("..")){
            throw new GlobalException(ResponseCode.FORBIDDEN);
        }
        byte[] bytes = fileService.getFile(fileName);
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Disposition", String.format("attachment; filename=\"%s\"", fileName));
        return new ResponseEntity<>(bytes,headers, HttpStatus.OK);
    }

    @ApiOperation("读取文件-限制指定路径")
    @PostMapping("/getFile2")
    public ResponseEntity<byte[]> getFile2(
            @ApiParam(value = "文件名", required = true)@RequestParam("fileName") String fileName) throws IOException {
        byte[] bytes = fileService.getFile(fileName);
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Disposition", String.format("attachment; filename=\"%s\"", fileName));
        return new ResponseEntity<>(bytes,headers, HttpStatus.OK);
    }
}
