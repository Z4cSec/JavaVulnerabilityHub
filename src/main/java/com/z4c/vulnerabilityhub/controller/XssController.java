package com.z4c.vulnerabilityhub.controller;

import com.z4c.vulnerabilityhub.model.User;
import com.z4c.vulnerabilityhub.service.CommandService;
import com.z4c.vulnerabilityhub.service.UserService;
import com.z4c.vulnerabilityhub.utils.XssUtils;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import springfox.documentation.annotations.ApiIgnore;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
@RequestMapping("/xss")
@Api(tags = "跨站脚本攻击(XSS)")
public class XssController {
    @Autowired
    CommandService commandService;

    @Autowired
    private UserService userService;

    @ApiIgnore
    @ApiOperation(value = "基于反射型的Xss页面",notes = "")
    @GetMapping("/reflective-xss")
    public String reflectiveXssIndex(){ return "reflect/reflective-xss"; }

    @ApiOperation(value = "基于Dom的Xss页面",notes = "http://ip/xss/dom-xss?invite=gistw%3Cimg%20src=%271%27%20onerror=%27alert(1)%27%3E")
    @GetMapping("/dom-xss")
    public String domXssIndex(){
        return "dom/dom-xss";
    }

    @ApiOperation(value = "基于Dom的Xss页面-修复",notes = "http://ip/xss/dom-xss?invite=gistw%3Cimg%20src=%271%27%20onerror=%27alert(1)%27%3E")
    @GetMapping("/filter-dom-xss")
    public String filterDomXssIndex(){
        return "dom/filter-dom-xss";
    }

    @ApiIgnore
    @ApiOperation(value = "基于存储型的Xss页面",notes = "")
    @GetMapping("/stored-xss")
    public String restoredXssIndex(){
        return "store/stored-xss";
    }


    @ApiOperation(value = "基于反射型的Xss",notes = "")
    @GetMapping("/reflective-xss/bad")
    public ResponseEntity<String> reflect(@RequestParam("host") String host) throws Exception {
        return ResponseEntity.ok(commandService.safeExecCommand(host));
    }



    /*
     *   反射型Xss修复方案一：
     *
     *   添加过滤函数，将用户传入的参数进行过滤
     *
     *
     */
    @ApiOperation(value = "基于反射型的Xss方法过滤修复",notes = "添加过滤函数，将用户传入的参数进行过滤")
    @GetMapping("/reflective-xss/filter")
    public ResponseEntity<String> filterReflect(@RequestParam("host") String host) throws Exception {
        host = XssUtils.xssEncode(host);
        return ResponseEntity.ok(commandService.safeExecCommand(host));
    }



    /*
     *   反射型Xss修复方案二：
     *
     *   添加全局过滤器（可通过注解@WebFilter配置需要被过滤的路径）
     *   用户所有传入的参数中包含的特殊字符被全局过滤器指定的函数进行替换，避免包含Xss恶意代码
     *
     */
    @ApiOperation(value = "基于反射型的Xss全局过滤修复",notes = "用户传入的参数中包含的特殊字符被全局过滤器进行替换，避免包含Xss恶意代码")
    @GetMapping("/reflective-xss/sanitized")
    public ResponseEntity<String> sanitizedReflect(@RequestParam("host") String host) throws Exception {
        return ResponseEntity.ok(commandService.safeExecCommand(host));
    }


    @ApiOperation(value = "基于存储型的Xss",notes = "")
    @GetMapping("/stored-xss/bad")
    public String store(){
        return "store/stored-xss";
    }



    /*
     *   存储型Xss修复方案一：
     *
     *   从数据库中获取数据后进行过滤再返回至前端，不推荐
     *
     */
    @ApiOperation(value = "基于存储型的Xss返回数据前过滤修复",notes = "")
    @GetMapping("/getAll")
    public ResponseEntity<HashMap<String, Object>> getAll(){
        List<User> users = userService.getAll();
        HashMap<String, Object> resultMap = new HashMap<>();
        resultMap.put("code", 0);
        resultMap.put("msg", "");
        resultMap.put("count", users.size());
        users = (List<User>)XssUtils.xssListEncode(users);//获取String属性进行过滤
        resultMap.put("data", users);
        return ResponseEntity.ok(resultMap);
    }

    /*
     *   存储型Xss修复方案二：
     *
     *   添加全局过滤器（可通过注解@WebFilter配置需要被过滤的路径）
     *   用户所有传入的参数中包含的特殊字符被全局过滤器指定的函数进行替换，避免包含Xss恶意代码
     *
     */
    @ApiOperation(value = "基于存储型的Xss全局过滤修复",notes = "")
    @GetMapping("/stored-xss/update")
    public ResponseEntity<Map<String,Object>> update(User user){
        HashMap<String, Object> resultMap = new HashMap<>();
        if(!userService.updateUser(user)){
            resultMap.put("code", 500);
            resultMap.put("msg", "服务器内部错误");
            return ResponseEntity.ok(resultMap);
        }
        resultMap.put("code", 0);
        resultMap.put("msg", "更新成功");
        return ResponseEntity.ok(resultMap);
    }
}
