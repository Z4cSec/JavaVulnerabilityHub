package com.z4c.vulnerabilityhub.utils;

import com.z4c.vulnerabilityhub.model.ResponseCode;
import com.z4c.vulnerabilityhub.globalException.GlobalException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.UUID;

@Component
public class FileUtils {
    @Value("${upload.file.path}")
    private String path;
    @Value("${upload.file.allowed-types}")
    private String[] allowedTypes;

    /*
     * 该方法存在以下缺陷
     *
     * 1、直接使用原始文件名作为服务器上的文件名，容易被攻击者利用进行文件名注入攻击，
     * 如上传一个文件名为 ../../../etc/passwd 的文件，可以让攻击者穿越目录，覆盖指定文件。
     * 2、没有对文件类型进行校验，攻击者可以上传任意类型的文件，从而增加服务器被攻击的风险。
     */

    public String uploadFile(MultipartFile file) {
        // 获取上传文件的原始文件名
        String originalFileName = file.getOriginalFilename();
        if (originalFileName == null) {
            throw new GlobalException(ResponseCode.FILE_NAME_NULL);
        }
        // 将文件保存到服务器
        String savePath = path + originalFileName;
        try {
            File save = new File(savePath);
            if (!save.exists()) {
                save.mkdirs(); // 创建多层目录
            }
            file.transferTo(save);
        } catch (IOException e) {
            e.printStackTrace();
            throw new GlobalException(ResponseCode.FILE_SAVE_ERROR);
        }
        return savePath;
    }

    /*
     * 第一种修复方案：
     *   文件名由服务器通过UUID进行生成，避免文件名中存在导致目录穿越的特殊字符
     *   通过白名单校验，只允许指定后缀文件上传
     */
    public String uploadFileRandomNameSanitizer(MultipartFile file) {
        // 获取上传文件的原始文件名
        String originalFileName = file.getOriginalFilename();
        if (originalFileName == null) {
            throw new GlobalException(ResponseCode.FILE_NAME_NULL);
        }
        // 获取文件名后缀
        String fileType = originalFileName.substring(originalFileName.lastIndexOf('.'));
        // 校验是否允许图片后缀文件上传
        if (!Arrays.asList(allowedTypes).contains(fileType)) {
            throw new GlobalException(ResponseCode.FILE_TYPE_UNSUPPORTED);
        }
        // 生成一个新的文件名
        String newFileName = UUID.randomUUID() + fileType;
        // 将文件保存到服务器
        String savePath = path + newFileName;
        try {
            file.transferTo(new File(savePath));
        } catch (IOException e) {
            e.printStackTrace();
            throw new GlobalException(ResponseCode.FILE_SAVE_ERROR);
        }
        return savePath;
    }

    /*
     * 第二种修复方案：
     *   通过判断保存路径是否在指定路径，避免目录穿越
     *   通过白名单校验，只允许指定后缀文件上传
     */
    public String uploadFileCanonicalSanitizer(MultipartFile file) {
        // 获取上传文件的原始文件名
        String originalFileName = file.getOriginalFilename();
        if (originalFileName == null) {
            throw new GlobalException(ResponseCode.FILE_NAME_NULL);
        }
        // 获取文件名后缀
        String fileType = originalFileName.substring(originalFileName.lastIndexOf('.'));
        // 校验是否允许图片后缀文件上传
        if (!Arrays.asList(allowedTypes).contains(fileType)) {
            throw new GlobalException(ResponseCode.FILE_TYPE_UNSUPPORTED);
        }

        File savePath = new File(path + originalFileName);
        String canonicalPath = null;
        try {
            canonicalPath = savePath.getCanonicalPath();
            //判断保存文件的路径开头是否为path
            if (!canonicalPath.startsWith(path)) {
                throw new GlobalException(ResponseCode.FILE_SAVE_ERROR);
            }
            // 将文件保存到服务器
            file.transferTo(savePath);
        } catch (IOException e) {
            e.printStackTrace();
            throw new GlobalException(ResponseCode.FILE_SAVE_ERROR);
        }
        return canonicalPath;
    }

}
